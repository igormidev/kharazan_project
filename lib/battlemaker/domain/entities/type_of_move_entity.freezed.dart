// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'type_of_move_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$TypeOfMoveEntity {
  CoordenatesInMove get coordenatesInMove => throw _privateConstructorUsedError;
  BoardPieceEntity get pieceInOrigin => throw _privateConstructorUsedError;
  List<BoardFieldEntity> get otherBoardEntities =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            List<BoardFieldEntity> otherBoardEntities)
        pieceChangingPosition,
    required TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            BoardPieceEntity pieceInDestiny,
            List<BoardFieldEntity> otherBoardEntities)
        pieceAttackingOther,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceChangingPosition,
    TResult? Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            BoardPieceEntity pieceInDestiny,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceAttackingOther,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceChangingPosition,
    TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            BoardPieceEntity pieceInDestiny,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceAttackingOther,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MoveTypeChangePiecePosition value)
        pieceChangingPosition,
    required TResult Function(_PieceAttackingOther value) pieceAttackingOther,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MoveTypeChangePiecePosition value)?
        pieceChangingPosition,
    TResult? Function(_PieceAttackingOther value)? pieceAttackingOther,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MoveTypeChangePiecePosition value)? pieceChangingPosition,
    TResult Function(_PieceAttackingOther value)? pieceAttackingOther,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TypeOfMoveEntityCopyWith<TypeOfMoveEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypeOfMoveEntityCopyWith<$Res> {
  factory $TypeOfMoveEntityCopyWith(
          TypeOfMoveEntity value, $Res Function(TypeOfMoveEntity) then) =
      _$TypeOfMoveEntityCopyWithImpl<$Res, TypeOfMoveEntity>;
  @useResult
  $Res call(
      {CoordenatesInMove coordenatesInMove,
      BoardPieceEntity pieceInOrigin,
      List<BoardFieldEntity> otherBoardEntities});
}

/// @nodoc
class _$TypeOfMoveEntityCopyWithImpl<$Res, $Val extends TypeOfMoveEntity>
    implements $TypeOfMoveEntityCopyWith<$Res> {
  _$TypeOfMoveEntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coordenatesInMove = null,
    Object? pieceInOrigin = null,
    Object? otherBoardEntities = null,
  }) {
    return _then(_value.copyWith(
      coordenatesInMove: null == coordenatesInMove
          ? _value.coordenatesInMove
          : coordenatesInMove // ignore: cast_nullable_to_non_nullable
              as CoordenatesInMove,
      pieceInOrigin: null == pieceInOrigin
          ? _value.pieceInOrigin
          : pieceInOrigin // ignore: cast_nullable_to_non_nullable
              as BoardPieceEntity,
      otherBoardEntities: null == otherBoardEntities
          ? _value.otherBoardEntities
          : otherBoardEntities // ignore: cast_nullable_to_non_nullable
              as List<BoardFieldEntity>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MoveTypeChangePiecePositionCopyWith<$Res>
    implements $TypeOfMoveEntityCopyWith<$Res> {
  factory _$$_MoveTypeChangePiecePositionCopyWith(
          _$_MoveTypeChangePiecePosition value,
          $Res Function(_$_MoveTypeChangePiecePosition) then) =
      __$$_MoveTypeChangePiecePositionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {CoordenatesInMove coordenatesInMove,
      BoardPieceEntity pieceInOrigin,
      List<BoardFieldEntity> otherBoardEntities});
}

/// @nodoc
class __$$_MoveTypeChangePiecePositionCopyWithImpl<$Res>
    extends _$TypeOfMoveEntityCopyWithImpl<$Res, _$_MoveTypeChangePiecePosition>
    implements _$$_MoveTypeChangePiecePositionCopyWith<$Res> {
  __$$_MoveTypeChangePiecePositionCopyWithImpl(
      _$_MoveTypeChangePiecePosition _value,
      $Res Function(_$_MoveTypeChangePiecePosition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coordenatesInMove = null,
    Object? pieceInOrigin = null,
    Object? otherBoardEntities = null,
  }) {
    return _then(_$_MoveTypeChangePiecePosition(
      coordenatesInMove: null == coordenatesInMove
          ? _value.coordenatesInMove
          : coordenatesInMove // ignore: cast_nullable_to_non_nullable
              as CoordenatesInMove,
      pieceInOrigin: null == pieceInOrigin
          ? _value.pieceInOrigin
          : pieceInOrigin // ignore: cast_nullable_to_non_nullable
              as BoardPieceEntity,
      otherBoardEntities: null == otherBoardEntities
          ? _value._otherBoardEntities
          : otherBoardEntities // ignore: cast_nullable_to_non_nullable
              as List<BoardFieldEntity>,
    ));
  }
}

/// @nodoc

class _$_MoveTypeChangePiecePosition implements _MoveTypeChangePiecePosition {
  const _$_MoveTypeChangePiecePosition(
      {required this.coordenatesInMove,
      required this.pieceInOrigin,
      required final List<BoardFieldEntity> otherBoardEntities})
      : _otherBoardEntities = otherBoardEntities;

  @override
  final CoordenatesInMove coordenatesInMove;
  @override
  final BoardPieceEntity pieceInOrigin;
  final List<BoardFieldEntity> _otherBoardEntities;
  @override
  List<BoardFieldEntity> get otherBoardEntities {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_otherBoardEntities);
  }

  @override
  String toString() {
    return 'TypeOfMoveEntity.pieceChangingPosition(coordenatesInMove: $coordenatesInMove, pieceInOrigin: $pieceInOrigin, otherBoardEntities: $otherBoardEntities)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MoveTypeChangePiecePosition &&
            (identical(other.coordenatesInMove, coordenatesInMove) ||
                other.coordenatesInMove == coordenatesInMove) &&
            const DeepCollectionEquality()
                .equals(other.pieceInOrigin, pieceInOrigin) &&
            const DeepCollectionEquality()
                .equals(other._otherBoardEntities, _otherBoardEntities));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      coordenatesInMove,
      const DeepCollectionEquality().hash(pieceInOrigin),
      const DeepCollectionEquality().hash(_otherBoardEntities));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MoveTypeChangePiecePositionCopyWith<_$_MoveTypeChangePiecePosition>
      get copyWith => __$$_MoveTypeChangePiecePositionCopyWithImpl<
          _$_MoveTypeChangePiecePosition>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            List<BoardFieldEntity> otherBoardEntities)
        pieceChangingPosition,
    required TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            BoardPieceEntity pieceInDestiny,
            List<BoardFieldEntity> otherBoardEntities)
        pieceAttackingOther,
  }) {
    return pieceChangingPosition(
        coordenatesInMove, pieceInOrigin, otherBoardEntities);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceChangingPosition,
    TResult? Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            BoardPieceEntity pieceInDestiny,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceAttackingOther,
  }) {
    return pieceChangingPosition?.call(
        coordenatesInMove, pieceInOrigin, otherBoardEntities);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceChangingPosition,
    TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            BoardPieceEntity pieceInDestiny,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceAttackingOther,
    required TResult orElse(),
  }) {
    if (pieceChangingPosition != null) {
      return pieceChangingPosition(
          coordenatesInMove, pieceInOrigin, otherBoardEntities);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MoveTypeChangePiecePosition value)
        pieceChangingPosition,
    required TResult Function(_PieceAttackingOther value) pieceAttackingOther,
  }) {
    return pieceChangingPosition(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MoveTypeChangePiecePosition value)?
        pieceChangingPosition,
    TResult? Function(_PieceAttackingOther value)? pieceAttackingOther,
  }) {
    return pieceChangingPosition?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MoveTypeChangePiecePosition value)? pieceChangingPosition,
    TResult Function(_PieceAttackingOther value)? pieceAttackingOther,
    required TResult orElse(),
  }) {
    if (pieceChangingPosition != null) {
      return pieceChangingPosition(this);
    }
    return orElse();
  }
}

abstract class _MoveTypeChangePiecePosition implements TypeOfMoveEntity {
  const factory _MoveTypeChangePiecePosition(
          {required final CoordenatesInMove coordenatesInMove,
          required final BoardPieceEntity pieceInOrigin,
          required final List<BoardFieldEntity> otherBoardEntities}) =
      _$_MoveTypeChangePiecePosition;

  @override
  CoordenatesInMove get coordenatesInMove;
  @override
  BoardPieceEntity get pieceInOrigin;
  @override
  List<BoardFieldEntity> get otherBoardEntities;
  @override
  @JsonKey(ignore: true)
  _$$_MoveTypeChangePiecePositionCopyWith<_$_MoveTypeChangePiecePosition>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_PieceAttackingOtherCopyWith<$Res>
    implements $TypeOfMoveEntityCopyWith<$Res> {
  factory _$$_PieceAttackingOtherCopyWith(_$_PieceAttackingOther value,
          $Res Function(_$_PieceAttackingOther) then) =
      __$$_PieceAttackingOtherCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {CoordenatesInMove coordenatesInMove,
      BoardPieceEntity pieceInOrigin,
      BoardPieceEntity pieceInDestiny,
      List<BoardFieldEntity> otherBoardEntities});
}

/// @nodoc
class __$$_PieceAttackingOtherCopyWithImpl<$Res>
    extends _$TypeOfMoveEntityCopyWithImpl<$Res, _$_PieceAttackingOther>
    implements _$$_PieceAttackingOtherCopyWith<$Res> {
  __$$_PieceAttackingOtherCopyWithImpl(_$_PieceAttackingOther _value,
      $Res Function(_$_PieceAttackingOther) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coordenatesInMove = null,
    Object? pieceInOrigin = null,
    Object? pieceInDestiny = null,
    Object? otherBoardEntities = null,
  }) {
    return _then(_$_PieceAttackingOther(
      coordenatesInMove: null == coordenatesInMove
          ? _value.coordenatesInMove
          : coordenatesInMove // ignore: cast_nullable_to_non_nullable
              as CoordenatesInMove,
      pieceInOrigin: null == pieceInOrigin
          ? _value.pieceInOrigin
          : pieceInOrigin // ignore: cast_nullable_to_non_nullable
              as BoardPieceEntity,
      pieceInDestiny: null == pieceInDestiny
          ? _value.pieceInDestiny
          : pieceInDestiny // ignore: cast_nullable_to_non_nullable
              as BoardPieceEntity,
      otherBoardEntities: null == otherBoardEntities
          ? _value._otherBoardEntities
          : otherBoardEntities // ignore: cast_nullable_to_non_nullable
              as List<BoardFieldEntity>,
    ));
  }
}

/// @nodoc

class _$_PieceAttackingOther implements _PieceAttackingOther {
  const _$_PieceAttackingOther(
      {required this.coordenatesInMove,
      required this.pieceInOrigin,
      required this.pieceInDestiny,
      required final List<BoardFieldEntity> otherBoardEntities})
      : _otherBoardEntities = otherBoardEntities;

  @override
  final CoordenatesInMove coordenatesInMove;
  @override
  final BoardPieceEntity pieceInOrigin;
  @override
  final BoardPieceEntity pieceInDestiny;
  final List<BoardFieldEntity> _otherBoardEntities;
  @override
  List<BoardFieldEntity> get otherBoardEntities {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_otherBoardEntities);
  }

  @override
  String toString() {
    return 'TypeOfMoveEntity.pieceAttackingOther(coordenatesInMove: $coordenatesInMove, pieceInOrigin: $pieceInOrigin, pieceInDestiny: $pieceInDestiny, otherBoardEntities: $otherBoardEntities)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PieceAttackingOther &&
            (identical(other.coordenatesInMove, coordenatesInMove) ||
                other.coordenatesInMove == coordenatesInMove) &&
            const DeepCollectionEquality()
                .equals(other.pieceInOrigin, pieceInOrigin) &&
            const DeepCollectionEquality()
                .equals(other.pieceInDestiny, pieceInDestiny) &&
            const DeepCollectionEquality()
                .equals(other._otherBoardEntities, _otherBoardEntities));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      coordenatesInMove,
      const DeepCollectionEquality().hash(pieceInOrigin),
      const DeepCollectionEquality().hash(pieceInDestiny),
      const DeepCollectionEquality().hash(_otherBoardEntities));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PieceAttackingOtherCopyWith<_$_PieceAttackingOther> get copyWith =>
      __$$_PieceAttackingOtherCopyWithImpl<_$_PieceAttackingOther>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            List<BoardFieldEntity> otherBoardEntities)
        pieceChangingPosition,
    required TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            BoardPieceEntity pieceInDestiny,
            List<BoardFieldEntity> otherBoardEntities)
        pieceAttackingOther,
  }) {
    return pieceAttackingOther(
        coordenatesInMove, pieceInOrigin, pieceInDestiny, otherBoardEntities);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceChangingPosition,
    TResult? Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            BoardPieceEntity pieceInDestiny,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceAttackingOther,
  }) {
    return pieceAttackingOther?.call(
        coordenatesInMove, pieceInOrigin, pieceInDestiny, otherBoardEntities);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceChangingPosition,
    TResult Function(
            CoordenatesInMove coordenatesInMove,
            BoardPieceEntity pieceInOrigin,
            BoardPieceEntity pieceInDestiny,
            List<BoardFieldEntity> otherBoardEntities)?
        pieceAttackingOther,
    required TResult orElse(),
  }) {
    if (pieceAttackingOther != null) {
      return pieceAttackingOther(
          coordenatesInMove, pieceInOrigin, pieceInDestiny, otherBoardEntities);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MoveTypeChangePiecePosition value)
        pieceChangingPosition,
    required TResult Function(_PieceAttackingOther value) pieceAttackingOther,
  }) {
    return pieceAttackingOther(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MoveTypeChangePiecePosition value)?
        pieceChangingPosition,
    TResult? Function(_PieceAttackingOther value)? pieceAttackingOther,
  }) {
    return pieceAttackingOther?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MoveTypeChangePiecePosition value)? pieceChangingPosition,
    TResult Function(_PieceAttackingOther value)? pieceAttackingOther,
    required TResult orElse(),
  }) {
    if (pieceAttackingOther != null) {
      return pieceAttackingOther(this);
    }
    return orElse();
  }
}

abstract class _PieceAttackingOther implements TypeOfMoveEntity {
  const factory _PieceAttackingOther(
          {required final CoordenatesInMove coordenatesInMove,
          required final BoardPieceEntity pieceInOrigin,
          required final BoardPieceEntity pieceInDestiny,
          required final List<BoardFieldEntity> otherBoardEntities}) =
      _$_PieceAttackingOther;

  @override
  CoordenatesInMove get coordenatesInMove;
  @override
  BoardPieceEntity get pieceInOrigin;
  BoardPieceEntity get pieceInDestiny;
  @override
  List<BoardFieldEntity> get otherBoardEntities;
  @override
  @JsonKey(ignore: true)
  _$$_PieceAttackingOtherCopyWith<_$_PieceAttackingOther> get copyWith =>
      throw _privateConstructorUsedError;
}
